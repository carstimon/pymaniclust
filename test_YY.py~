import pymanopt as mo

from pymanopt.manifolds import Stiefel
from pymanopt.solvers import SteepestDescent

from sklearn.cluster import KMeans


import numpy as np
import numpy.linalg as la
import numpy.random as nrand
import scipy.linalg as sla
import scipy.sparse.linalg as spla
import autograd.numpy as anp

import Y_mani
from Cluster_Pblm import Cluster_Pblm

import itertools
import collections

from random_creators import *

DATAFOLDER = "data/"

###
### Functions for generating random problems
###

def stoch_ball_pblm(nballs, npts, dist_cent):
    """
    Creates a basic test problem.
    k = nballs.
    There are k balls in \real^k with equal spacing.  From each ball we draw an equal number of points (npts).
    The balls have radius one, and lie on the simplex with edge length dist_cent.
    """
    cs = np.eye(nballs)*dist_cent/np.sqrt(2) #Centers on simplex with distance dist_cent from eachother.
    P = stoch_ball([1]*nballs, cs, [npts]*nballs)
    return Cluster_Pblm(P, nballs)

def stoch_ball_pblm_uneven(npts_list, dist_cent):
    """
    Similar to stoch_ball_pblm,
    but is able to draw different numbers of points from each ball.
    npts_list is the list of number of points, the number of balls is the length of this list.
    dist_cent is the distance between the centers.
    """
    nballs = len(npts_list)
    cs = np.eye(nballs)*dist_cent/np.sqrt(2) #Centers on simplex with distance dist_cent from eachother.
    P = stoch_ball([1]*nballs, cs, npts_list)
    return Cluster_Pblm(P,nballs)


###
### Functions for generating solutions and saving.
###

        
def gen_local_mins(pblm, a, b, N, eps = None):
    """
    Runs the minimization for the Cluster_Pblm pblm N times, for a random point and coefficients (a,b).
    Does it N times and returns the minimizers.
    If eps is not None, prunes the minimizers with tolerance eps.
    Returns the triplets (Y_minimizing, tr(Y), neg(Y))
    """
    Ys = []
    for j in range(N):
        Y,_ = pblm.run_minimization(a, b)
        Ys.append((Y,pblm.tr(Y), pblm.neg(Y)))
    if eps is not None:
        prune_mins(Ys, eps)
    return Ys


def gen_many_mins(pblm, As, Bs, N, suffix=None, eps=.01):
    """
    Generates local minimizers for the Cluster Problem pblm.
    For each (a,b) pair runs it N times.

    If suffix is not none, the data is saved to file.
    Also saves the problems P and k values.
    
    Also prints the current (a,b) pair under consideration, and how many minimizers were generated.
    """
    A_list, B_list, trs, negs = [],[],[],[]
    data = [A_list, B_list, trs, negs, pblm.P, pblm.k]
    datanames = ["As","Bs","trs","negs", "P", "k"]
    for (a,b) in zip(As, Bs):
        print("(a,b): " + str((a,b)))
        Ys = gen_local_mins(pblm, a, b, N, eps=eps)
        print("minimizers generated: " + str(len(Ys)))
        for Y, tr, neg in Ys:
            A_list.append(a)
            B_list.append(b)
            trs.append(tr)
            negs.append(neg)
    if suffix is not None:
        for datum, name in zip(data, datanames):
            np.save(DATAFOLDER + name + "_" + suffix, datum)
    return A_list, B_list, trs, negs

def gen_path(pblm, As, Bs, suffix):
    """
    Generates a path  from the homotopy method for the Cluster_Pblm pblm,
    with (a,b) pairs given by As and Bs
    Saves to files given by suffix.
    Also saves the problem's P and k values.
    """
    Ys = pblm.do_path(As, Bs, save=True)[1]
    datanames = ["As_path", "Bs_path", "trs_path", "negs_path", "P", "k"]
    trs = [pblm.tr(Y) for Y in Ys]
    negs = [pblm.neg(Y) for Y in Ys]
    B_path = np.hstack([0,Bs])
    A_path = np.hstack([1,As])
    data = [A_path, B_path, trs, negs, pblm.P, pblm.k]
    for datum, name in zip(data, datanames):
        np.save(DATAFOLDER + name + "_" + suffix, datum)

def gen_lloyd_comp(pblm_generator, As, Bs, N, suffix=None,     num_lloyd_runs = 5):
    pblm = pblm_generator()
    lloyd_values = [pblm.tr(pblm.run_lloyd()) for j in range(num_lloyd_runs)]
    Y_from_path = pblm.M.round_clustering(pblm.do_path(As, Bs)[0])
    homotopy_value = pblm.tr(Y_from_path)
    return homotopy_value, lloyd_values
    

###
### Functions for loading data generated to files
###

def load_mins(suffix):
    """
    Loads the saved minimizers corresponding to the string suffix, as generated by gen_many_mins
    Returns the tuple (As, Bs, trs, negs)
    where As and Bs are the coefficient a and b for each minimizer,
    trs and negs are the respective functions.
    """
    datanames = ["As","Bs","trs","negs"]
    return (np.load(DATAFOLDER + name + "_" + suffix + ".npy") for name in datanames)

def load_path(suffix):
    """
    Loads the saved path corresponding to the string suffix, as generated by gen_path.
    Returns the tuple As, Bs, trs, negs
    where As and Bs are the coefficient a and b for each point on the path,
    trs and negs are the respective functions.
    """
    datanames = ["As_path", "Bs_path", "trs_path", "negs_path"]
    return (np.load(DATAFOLDER + name + "_" + suffix + ".npy") for name in datanames)

def load_pblm(suffix):
    """
    Given a suffix string, loads the P matrix and k value and returns a Cluster_Pblm object for that data.
    """
    P = np.load(DATAFOLDER + "P_" + suffix + ".npy")
    k = np.load(DATAFOLDER + "k_" + suffix + ".npy")
    return Cluster_Pblm(P,k)
    

###
### Functions for comparing matrices.
###
    
def compare_permuting(A,B):
    """
    Finds the permutation of B's columns so that ||A-B||_{\infty} is minimized.
    Returns the value of ||A-B||_{\infty}, as well as B permuted in the best way.
    """
    m = np.inf
    Bpermedbest = None
    for perm in itertools.permutations(range(np.shape(A)[1])):
        Bpermed = col_permute(B, perm)
        diff = la.norm(la.norm(A-Bpermed, np.inf, axis=1), np.inf)
        if diff<m:
            m = diff
            Bpermedbest = Bpermed
    return m, Bpermedbest

def col_permute(A, perm):
    perm = list(perm)
    inds = np.argsort(perm)
    return(A[:,inds])

def prune_mins(lst, eps):
    """
    Given a list of tuples
    (matrix, tr_value, neg_value)
    sorts the list (in place) by tr_value
    and then prunes matrices which are less than eps away in the sup norm, up to column permutation.
    """
    lst.sort(key = lambda x: x[1]) #Sort by cost_trace.
    i = 0
    while i < len(lst)-1:
        while (i < len(lst)-1
               and compare_permuting(lst[i][0], lst[i+1][0])[0] < eps):
            lst.pop(i+1)
        i+=1
        
def comps(lst):
    """
    The idea of this was to just make a list of differences when permuted the best way.
    It is not tested or used by anything else currently, so it should be checked before use.
    """
    lst.sort(key = lambda x: x[1]) #Sort by cost_trace.
    diffs = []
    permeds = [lst[0][0]]
    for i in range(len(lst)-1):
        diff, Bpermed = compare_permuting(lst[i][0], lst[i+1][0])
        diffs.append(diff)
        permeds.append(Bpermed)
    return diffs, permeds


###
### Hold minimizers
###

class Pblm_Test:
    """
    Hold some information about a problem
    and has the ability to save it.
    """
    def __init__(self, pblm):
        self.pblm = pblm
        #a path is a list of pairs (ts, Y).
        self.paths = []
        #Dict taking t's and giving a list of local mins we've found at that t-level.
        self.local_mins_found = []
        
        
        

    def ab_map(self, t):
        return (1-t), self.pblm.Dsize*t

    def run_path(self, tstep):
        ts = np.arange(tstep, 1, tstep)**(.5)
        ts_full = np.hstack([0, ts, 1])
        As, Bs = self.ab_map(np.arange(tstep, 1, tstep))
        _, Ys = self.pblm.do_path(As, Bs, smart_start=True, save=True)
        self.paths.append((ts_full, Ys))

    def initiate_splitter(self):
        Y0,_ = self.pblm.run_minimization(1, 0)
        LM0 = Local_Min(0, Y0, self.pblm)
        Y1,_ = self.pblm.run_minimization(0, 1, Y0 = Y0)
        LM1 = Local_Min(1, Y1, self.pblm)
        LM0.add_conn(LM1)
        self.local_mins_found.append(LM0)
        self.local_mins_found.append(LM1)

    def add_LM(self, LM):
        if LM in self.local_mins_found:
            i = self.local_mins_found.index(LM)
            return self.local_mins_found[i]
        else:
            self.local_mins_found.append(LM)
            return LM

    def split_min(self,LM):
        LM_next = LM.closest_conn()
        t_next = LM_next.t
        a_next, b_next = self.ab_map(t_next)
        t_new = (LM.t + t_next)/2
        
        a_new, b_new = self.ab_map(t_new)
        Y_new,_ = self.pblm.run_minimization(a_new, b_new, Y0 = LM.Y)
        LM_new = Local_Min(t_new, Y_new, self.pblm)
        LM_new = self.add_LM(LM_new)
        LM.add_conn(LM_new)

        Y_new2, _ = self.pblm.run_minimization(a_next, b_next, Y0 = Y_new)
        LM_new2 = Local_Min(t_next, Y_new2, self.pblm)
        if LM_new2 != LM_next:
            print("New LM")
        LM_new2 = self.add_LM(LM_new2)
        LM_new.add_conn(LM_new2)

    def print_LMS(self):
        num = len(self.local_mins_found)
        for (j, LM) in zip(range(num), self.local_mins_found):
            print(str(j) + ": " + str(LM))

    def plt_LMS(self, fig):
        ts = [LM.t for LM in self.local_mins_found]
        trs = [LM.tr for LM in self.local_mins_found]
        fig.clear()
        ax = fig.add_subplot(111)
        ax.scatter(ts, trs)


        



        
class Local_Min:
    def __init__(self, t, Y, pblm):
        self.eps = .1
        self.tr = pblm.tr(Y)
        self.neg = pblm.neg(Y)
        self.Y = Y
        self.t = t
        #List of Local_Mins reached from this one.
        self.conns = []

    def add_conn(self, other):
        self.conns.append(other)

    def closest_conn(self):
        return min(self.conns, key= lambda LM: LM.t)

    def hop_dist(self):
        return compare_permuting(self.Y, self.closest_conn().Y)[0]
        
    def __eq__(self, other):
        return (self.t == other.t
                and compare_permuting(self.Y, other.Y)[0] < self.eps)
        
    def __str__(self):
        return "Local min at " + str(self.t) + " with tr " + str(self.tr)

    __repr__ = __str__
    
        
